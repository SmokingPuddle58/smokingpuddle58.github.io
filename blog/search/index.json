[{"content":"Import necessary libraries 1 import sqlite3 Connect to database 1 2 3 4 5 6 7 # The database that you want to access # If the database does not exist, it will be created connection = sqlite3.connect(\u0026#39;mydatabase.db\u0026#39;) # This will create a new database in the memory only. # The database vanishes when the program ends connection = sqlite3.connect(\u0026#39;:memory:\u0026#39;) Create a table 1 2 3 4 5 6 7 8 9 10 # Create a cursor cursor = connection.cursor() # Create a table cursor.execute (\u0026#34;\u0026#34;\u0026#34; CREATE TABLE tablename ( var1 DATATYPE, var2 DATATYPE, var3 DATATYPE )\u0026#34;\u0026#34;\u0026#34;) Datatype NULL Indicating existence. NULL if not exist. INTEGER Integer value. REAL Float value. TEXT Text value. BLOG: Binary large object. Commit changes to the database 1 connection.commit() Insert one data into the table 1 2 3 cursor.exectute(\u0026#34;\u0026#34;\u0026#34; INSERT INTO tablename VALUES (\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;) \u0026#34;\u0026#34;\u0026#34;) Insert many data into the table 1 2 3 4 5 6 7 8 9 # Create a list of tuples data = [ (\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;), (\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;), (\u0026#39;value1\u0026#39;, \u0026#39;value2\u0026#39;, \u0026#39;value3\u0026#39;) ] cursor.exectutemany(\u0026#34;\u0026#34;\u0026#34; INSERT INTO tablename VALUES (?,?,?)\u0026#34;\u0026#34;\u0026#34;, data) ) Query the database 1 2 3 4 5 6 7 # Select all data from the table cursor.execute(\u0026#34;SELECT * FROM tablename\u0026#34;) # Fetch all data # cursor.fetchone() # cursor.fetchmany(int) data = cursor.fetchall() WHERE clause 1 2 3 4 5 # To select data that with var1 is \u0026#39;value1\u0026#39; cursor.execute(\u0026#34;SELECT * FROM tablename WHERE var1 = \u0026#39;value1\u0026#39;\u0026#34;) # To select data that with var1 begins with \u0026#39;val\u0026#39;. % is a wildcard character. cursor.execute(\u0026#34;SELECT * FROM tablename WHERE var1 LIKE \u0026#39;val%\u0026#39;\u0026#34;) Update records 1 2 3 4 5 6 7 8 9 10 11 # Update all records with var2 = \u0026#39;value2\u0026#39; to var1 = \u0026#39;new_value\u0026#39; cursor.execute(\u0026#34;\u0026#34;\u0026#34; UPDATE tablename SET var1 = \u0026#39;new_value\u0026#39; WHERE var2 = \u0026#39;value2\u0026#39; \u0026#34;\u0026#34;\u0026#34;) # Update record with rowid 1 to var1 = \u0026#39;new_value\u0026#39; cursor.execute(\u0026#34;\u0026#34;\u0026#34; UPDATE tablename SET var1 = \u0026#39;new_value\u0026#39; WHERE rowid = 1 \u0026#34;\u0026#34;\u0026#34;) Delete records 1 2 3 4 5 6 7 8 9 # Delete all records with var1 = \u0026#39;value1\u0026#39; cursor.execute(\u0026#34;\u0026#34;\u0026#34; DELETE FROM tablename WHERE var1 = \u0026#39;value1\u0026#39; \u0026#34;\u0026#34;\u0026#34;) # Delete record with rowid 1 cursor.execute(\u0026#34;\u0026#34;\u0026#34; DELETE FROM tablename WHERE rowid = 1 \u0026#34;\u0026#34;\u0026#34;) Ordering 1 2 # Order by rowid in descending order cursor.execute(\u0026#34;SELECT * FROM tablename ORDER BY rowid DESC\u0026#34;) AND/OR 1 2 # To select data that with var1 begins with \u0026#39;val\u0026#39; and rowid is 3. cursor.execute(\u0026#34;SELECT * FROM tablename WHERE var1 LIKE \u0026#39;val%\u0026#39; AND rowid = 3\u0026#34;) LIMIT 1 2 # To select data that with var1 begins with \u0026#39;val\u0026#39; and rowid is 3. Limit to 2 results cursor.execute(\u0026#34;SELECT * FROM tablename WHERE var1 LIKE \u0026#39;val%\u0026#39; AND rowid = 3 LIMIT 2\u0026#34;) Drop table 1 cursor.execute(\u0026#34;DROP TABLE tablename\u0026#34;) Close the connection when finished accessing table 1 connection.close() ","date":"2024-03-13T00:00:00Z","permalink":"https://smokingpuddle58.github.io/blog/p/sql3/","title":"Database with SQLite3 in Python"},{"content":"Laplacian operator Note that the Laplacian operator is the simplest isotropic derivative kernel. For any image $f(x,y)$, it is defined as:\n$$\\nabla^2f=\\frac{\\partial f}{\\partial x^2} + \\frac{\\partial f}{\\partial y^2}$$\nSince derivatives of any order are linear operation, thus Laplacian is also a linear operator.\nIf we define the derivatives as the following:\n$$\\frac{\\partial f}{\\partial x} = f (x + 1) - f (x)$$\nThen it is not difficult to derive that: $$\\frac{\\partial^2 f}{\\partial x^2} = f (x + 1) + f (x - 1) - 2 f (x)$$\nSince:\n$$\\begin{array}{lll} \\frac{\\partial^2 f}{\\partial x^2} \u0026amp; = \u0026amp; f (x + 1) - f (x) - (f (x) - f (x - 1))\\\\\\\\ \u0026amp; = \u0026amp; f (x + 1) + f (x - 1) - 2 f (x) \\end{array}$$\nWe can then derive that:\n$$\\begin{cases} \\frac{\\partial^2 f}{\\partial x^2} = f (x + 1, y) + f (x - 1, y) - 2 f (x, y)\\\\\\\\ \\frac{\\partial^2 f}{\\partial y^2} = f (x, y + 1) + f (x, y - 1) - 2 f (x, y) \\end{cases}$$\nThus:\n$$\\nabla^2f=f (x + 1, y) + f (x - 1, y) +f (x, y + 1) + f (x, y - 1) - 4 f (x,y)$$\nWe let the central of the kernel to be $(x,y)$. Then we can consider using the concept of convolution to find a operator. The reason is that the convolution is defined as the elementwise product of the kernel and the image.\nthe formula ($\\nabla^2f$) of Laplacian filter we stated above can be written as:\n$$\\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0\\\\ 1 \u0026amp; -4 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 0\\\\ \\end{bmatrix}$$\nWe can obtain the sharpened image $g(x,y)$ by adding the Laplacian of the image to the original image, which is:\n$$g(x,y)=f(x,y)-c[\\nabla^2f(x,y)]$$\nFilter with first-order derivative We define the gradient of an image $f$ as:\n$$ \\nabla f = \\text{grad}(f)=\\begin{bmatrix} \\frac{\\partial f}{\\partial x}\\\\ \\frac{\\partial f}{\\partial y} \\end{bmatrix} $$\nTo be continued\n","date":"2024-03-03T00:00:00Z","permalink":"https://smokingpuddle58.github.io/blog/p/spatial-filters/","title":"Sharpening (Highpass) Spatial Filters"},{"content":"Smoothing spatial filters are used mainly for noise reduction, reduce aliasing and some irrelevant details in the image. There are different types of such filters, which will be introduced below.\nBox Filter Kernels This is the most simple filter kernel. This filter can be created by creating an $m\\times n$ array with all 1\u0026rsquo;s, then every element is divided by the sum of coefficients in the array (In this case, $\\frac{1}{mn}$). To create such a kernel in numpy, we can use the following code.\n1 averaging_filter = np.ones((m,n)) / (m * n) For example, a $3\\times 3$ averaging filter will look like this:\n$$ \\begin{bmatrix} \\frac{1}{9} \u0026amp; \\frac{1}{9} \u0026amp; \\frac{1}{9} \\\\ \u0026amp; \\\\ \\frac{1}{9} \u0026amp; \\frac{1}{9} \u0026amp; \\frac{1}{9} \\\\ \u0026amp; \\\\ \\frac{1}{9} \u0026amp; \\frac{1}{9} \u0026amp; \\frac{1}{9} \\\\ \\end{bmatrix} $$\nThe filter are suitable for quick experimentation. However, it is a poor approximation to blurring characteristics of lenses, also the filter only favor blurring along prependicular directions.\nLowpass Gaussian Filter Kernels Gaussian kernel is the only circularly symmetric kernels that are separable. It is in the following form.\n$$w(s,t) = G(s,t) = \\frac{1}{2\\pi\\sigma}e^{-\\frac{s^2+t^2}{2\\sigma^2}}$$\nIt is possible to derive arbitrary $n\\times n$ Gaussian filter kernels for given $\\sigma$, where $n$ is odd number.\nThe center of the Gaussian filter $(x,y)$ must be 0. The following is a example of $3\\times 3$ matrix for calculating Gaussian filter:\n$$ \\left[\\begin{array}{ccc} (- 1, - 1) \u0026amp; (0, - 1) \u0026amp; (1, - 1)\\\\ (- 1, 0) \u0026amp; (0, 0) \u0026amp; (1, 0)\\\\ (- 1, 1) \u0026amp; (0, 1) \u0026amp; (1, 1)\\\\ \\end{array}\\right] $$\nSubstitude the value of $x,y$ and $\\sigma$ into the formula stated above, performing normalization, we can then get the Gaussian filter. In this case, for simplicity, if we let $\\sigma=1$, then we have the kernel to be:\n$$ \\left[\\begin{array}{ccc} (- 1, - 1) \u0026amp; (0, - 1) \u0026amp; (1, - 1)\\\\ (- 1, 0) \u0026amp; (0, 0) \u0026amp; (1, 0)\\\\ (- 1, 1) \u0026amp; (0, 1) \u0026amp; (1, 1)\\\\ \\end{array}\\right] $$\nMedian Filter Kernel - Non-linear Filter Kernel A non-linear filter will examine neighbours using various orderings, one of the most common one is order statistics. While a linear filter is a linear operation that its\u0026rsquo; output can be expressed as the convolution of image with filter. Moreover, linear filters have corresponding frequency domain filter.\nAmong the non-linear filter kernel, one of the most popular one is median filter. It examines the neighbourhood pixels, and find the median of the window. The filter kernel preserves edges, while removing impulse noise, and it avoids excessive smoothing.\n","date":"2024-03-03T00:00:00Z","permalink":"https://smokingpuddle58.github.io/blog/p/smoothing-spatial-filters/","title":"Smoothing (Lowpass) Spatial Filters"},{"content":"Hello World This is my first blog.\n1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello World!\u0026#34; \u0026lt;\u0026lt; endl; return 0; } ","date":"2023-09-09T00:00:00Z","permalink":"https://smokingpuddle58.github.io/blog/p/hello-world/","title":"First Blog"}]